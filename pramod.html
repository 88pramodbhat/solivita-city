<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <h1>Algorithm Concepts</h1>

    <h2>1) Problem-Solving Approaches Inspired by Nature</h2>
    <ul>
        <li><strong>Iteration:</strong> Solving problems step by step using loops (e.g., calculating factorials or traversing arrays).</li>
        <li><strong>Recursion:</strong> Breaking down a problem into smaller, simpler instances (e.g., Fibonacci sequence, Tower of Hanoi).</li>
        <li><strong>Backtracking:</strong> Systematically exploring all solutions while discarding invalid options (e.g., N-Queens problem, maze navigation, Sudoku).</li>
    </ul>

    <h2>2) Balancing Time and Space Efficiency</h2>
    <ul>
        <li><strong>Time Efficiency:</strong> Focuses on how quickly an algorithm executes.</li>
        <li><strong>Space Efficiency:</strong> Evaluates the memory required during execution.</li>
    </ul>
    <p>Algorithms are classified by growth rates like <strong>O(1)</strong> (constant time) or <strong>O(n²)</strong> (quadratic time). Computational problems fall into categories such as <strong>P</strong>, <strong>NP</strong>, <strong>NP-Hard</strong>, and <strong>NP-Complete</strong>, each significant in theoretical computer science.</p>

    <h2>3) Principles for Designing Algorithms</h2>
    <ul>
        <li><strong>Divide-and-Conquer:</strong> Breaks problems into smaller, manageable parts (e.g., merge sort, quick sort).</li>
        <li><strong>Greedy Approach:</strong> Makes locally optimal choices for global solutions (e.g., Kruskal’s, Prim’s algorithms).</li>
        <li><strong>Dynamic Programming:</strong> Avoids redundant calculations by storing intermediate results (e.g., knapsack problem, longest common subsequence).</li>
    </ul>

    <h2>4) Managing Hierarchical Data with Trees</h2>
    <ul>
        <li><strong>Binary Trees:</strong> Store data hierarchically, such as in file systems.</li>
        <li><strong>Binary Search Trees (BSTs):</strong> Enable efficient searching and insertion.</li>
        <li><strong>Self-Balancing Trees:</strong> Ensure consistent performance (e.g., AVL, Red-Black Trees).</li>
        <li><strong>Heaps:</strong> Ideal for priority queues.</li>
        <li><strong>Tries:</strong> Useful for autocomplete or dictionary lookups.</li>
    </ul>

    <h2>5) Efficient Array Queries</h2>
    <ul>
        <li><strong>Prefix Sum Arrays:</strong> Allow quick cumulative sum computations.</li>
        <li><strong>Fenwick Trees:</strong> Provide efficient prefix sums and updates.</li>
        <li><strong>Segment Trees:</strong> Offer range queries and updates, popular in competitive programming.</li>
    </ul>

    <h2>6) Distinctions Between Trees and Graphs</h2>
    <table>
        <thead>
            <tr>
                <th>Trees</th>
                <th>Graphs</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Hierarchical, no cycles</td>
                <td>Can be non-hierarchical, may have cycles</td>
            </tr>
            <tr>
                <td>Traversals include Preorder, Inorder, Postorder</td>
                <td>Traversals include DFS and BFS</td>
            </tr>
            <tr>
                <td>Used in family trees, file directories</td>
                <td>Used in networks, social graphs</td>
            </tr>
        </tbody>
    </table>

    <h2>7) Sorting and Searching Fundamentals</h2>
    <ul>
        <li><strong>Sorting Algorithms:</strong> Bubble sort, merge sort, quick sort, radix sort.</li>
        <li><strong>Searching Algorithms:</strong> Linear search (unsorted data), binary search (sorted data).</li>
    </ul>

    <h2>8) Graph Algorithms for Network Problems</h2>
    <ul>
        <li><strong>Minimum Spanning Trees (MST):</strong> Kruskal’s and Prim’s algorithms optimize networks, like electrical grids.</li>
        <li><strong>Shortest Path Algorithms:</strong> Techniques like Dijkstra’s and Bellman-Ford are vital for routing and navigation systems.</li>
    </ul>

    <h2>9) Key Questions to Guide Algorithm Design</h2>
    <ul>
        <li>What is the most efficient strategy for solving the problem?</li>
        <li>Are there trade-offs between simplicity and optimization?</li>
        <li>Should you create a new approach, or is it better to rely on proven methods?</li>
    </ul>
</body>
</html>

