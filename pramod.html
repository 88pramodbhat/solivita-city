<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <h1>Algorithm Concepts</h1>

    <h2>1) 1) what are the kinds of problems we see in nature?</h2>
    <ul>
        <li><strong>Iteration:</strong> solving problems step by step using loops (e.g., sum of numbers or traversing arrays ).</li>
        <li><strong>Recursion:</strong> breaking down a problem into smaller, simpler instances (e.g., Fibonacci sequence, tower of brahma).</li>
        <li><strong>Backtracking:</strong> systematically exploring all solutions while discarding invalid options (e.g., N-Queens problem, maze navigation, sudoku).</li>
    </ul>

    <h2>2) what is space and time complexity?</h2>
    <ul>
        <li><strong>time efficiency:</strong>extra time taken by algorithm to execute.</li>
        <li><strong>Space Efficiency:</strong> extra space occupied by program.</li>
    </ul>
    <p>Algorithms are classified by growth rates like <strong>O(1)</strong> (constant time) or <strong>O(n²)</strong> (quadratic time). so on helps to know the efficiency of the algorithm</p>

    <h2>3) take away from differnt design principles from chapter 2</h2>
    <ul>
         <li><strong>dynamic Programming:</strong> avoids redundant calculations by storing intermediate results (e.g. knapsack problem).</li>
        <li><strong>divide-and-conquer:</strong> Breaks problems into smaller, manageable parts (e.g. merge sort, quick sort).</li>
       
    </ul>

    <h2>4) the hierarchial data and how differnt  data structures solve and optimize over the problem scenario</h2>
    <ul>
        <li><strong>binary trees:</strong> Store data hierarchically, such as parent connected to child.</li>
        <li><strong>binary Search Trees (BST):</strong> enable efficient searching and insertion.</li>
        <li><strong>Self-Balancing Trees:</strong> Ensure consistent performance (heap, AVL, RedBlack Trees).</li>
        <li><strong>heaps:</strong> ideal for priority queues.balances itself</li>
        <li><strong>tries:</strong> useful for autocomplete or dictionary lookups. but occupies more space</li>
    </ul>

    <h2>5) the need of array query algorithms and their imlplication and their appication need to be discussed</h2>
    <ul>
        <li><strong>Prefix Sum Arrays:</strong> Allow quick cumulative sum computations.</li>
        <li><strong>Fenwick Trees:</strong> Provide efficient prefix sums and updates.</li>
        <li><strong>Segment Trees:</strong> Offer range queries and updates, popular in competitive programming.</li>
    </ul>

    <h2>6) difference between trees and graphs</h2>
    <table>
        <thead>
            <tr>
                <th>Trees</th>
                <th>Graphs</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Hierarchical, no cycles,Used in family trees, file directories</td>
                <td>Can be non-hierarchical, may have cycles,Used in networks, social graphs</td>
            </tr>
            <tr>
                <td>Traversals include Preorder, Inorder, Postorder</td>
                <td>Traversals include DFS and BFS</td>
            </tr>
            <tr>
            </tr>
        </tbody>
    </table>

    <h2>7) Sorting and Searching Fundamentals</h2>
    <ul>
        <li><strong>Sorting Algorithms:</strong> Bubble sort, merge sort, quick sort</li>
        <li><strong>Searching Algorithms:</strong> Linear search (unsorted data), binary search</li>
    </ul>

    <h2>8) Graph Algorithms for Network Problems</h2>
    <ul>
        <li><strong>Minimum Spanning Trees (MST):</strong> Kruskal’s and Prim’s algorithms optimize networks, like electrical grids.</li>
        <li><strong>Shortest Path Algorithms:</strong> Techniques like Dijkstra’s and Bellman-Ford are vital for routing and navigation systems.</li>
    </ul>

   

</body>
</html>

