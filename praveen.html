### 1. *Problems in Nature: Iteration, Recursion, and Backtracking*

- *Iteration*: Repeating actions until a condition is met.  
  Example: Waves in the ocean repeating in cycles.

- *Recursion*: Solving problems by breaking them into smaller parts of the same type.  
  Example: Patterns in snowflakes or ferns.

- *Backtracking*: Trying all possible paths and stepping back when something doesn’t work.  
  Example: Ants searching for the shortest path to food.

---

### 2. *Space and Time Efficiency*

- *Space Efficiency*: The memory a program uses.  
  Important for devices with limited memory.  

- *Time Efficiency*: How fast a program runs.  
  Important for saving time and resources.  

- *Orders of Growth*:
  - *Constant Time (O(1))*: Quick, like looking up a name in a small list.
  - *Linear Time (O(n))*: Proportional to input size, like scanning through a book.
  - *Exponential Time (O(2^n))*: Very slow, like testing every move in chess.

---

### 3. *Design Principles (Chapter 2)*  
- *Divide and Conquer*: Break the problem into smaller parts.  
- *Abstraction*: Focus on the key idea, ignore details.  
- *Modularity*: Design in pieces that can work independently.

---

### 4. *Hierarchical Data and Trees*  

- *Tree*: Represents relationships, like a family tree.  
- *Binary Search Tree (BST)*: Fast searching by dividing data in halves.  
- *AVL Tree*: Keeps the tree balanced for better performance.  
- *Red-Black Tree*: Similar to AVL but faster in some cases.  
- *Heap*: Used for priority tasks (e.g., job scheduling).  
- *Trie*: Stores words for quick searches (e.g., auto-suggestions).

---

### 5. *Array Query Algorithms*  

- Solve problems like finding the sum or max of a subarray.  
  Examples:
  - *Prefix Sum*: Speeds up repeated sum queries.
  - *Sliding Window*: Efficient for ranges (e.g., tracking the highest temperature in a week).  

*Applications*: Search engines, weather predictions.

---

### 6. *Trees vs. Graphs*  

- *Tree*: Hierarchical (e.g., file systems).  
- *Graph*: Network connections (e.g., social networks).  

*Traversals*:
- *Tree Traversals*: Preorder, Inorder, Postorder (used in parsing expressions).  
- *Graph Traversals*: BFS, DFS (used in shortest path and network analysis).

---

### 7. *Sorting and Searching Algorithms*  

- *Sorting*: Organize data (e.g., arranging names alphabetically).  
  - QuickSort: Fast, divide-and-conquer.
  - MergeSort: Stable, used in large datasets.  

- *Searching*: Find specific data (e.g., locating a book in a library).  
  - Binary Search: Efficient for sorted data.  

Real-world Use: E-commerce (sorting products), GPS (searching routes).

